---
description: Kotlin Ktor development guidelines with feature-based architecture, SOLID principles, and security best practices
globs: **/*.kt
---

# Kotlin Ktor Development Rules

## Instruction to developer: save this file as .cursorrules and place it on the root project directory

## Core Principles
- Follow **SOLID**, **DRY**, **KISS**, and **YAGNI** principles
- Adhere to **OWASP** security best practices
- Break tasks into smallest units and solve problems step-by-step

## Technology Stack
- **Framework**: Kotlin Ktor with Kotlin 2.1.20+
- **JDK**: 21 (LTS)
- **Build**: Gradle with Kotlin DSL
- **Dependencies**: Ktor Server Core/Netty, kotlinx.serialization, Exposed, HikariCP, kotlin-logging, Koin, Kotest

## Application Structure (Feature-Based)
- **Organize by business features, not technical layers**
- Each feature is self-contained with all related components
- Promotes modularity, reusability, and better team collaboration
- Makes codebase easier to navigate and maintain
- Enables parallel development on different features
```
src/main/kotlin/com/company/app/
├── common/              # Shared utilities, extensions
├── config/              # Application configuration, DI
└── features/
    ├── auth/            # Feature directory
    │   ├── models/
    │   ├── repositories/
    │   ├── services/
    │   └── routes/
    └── users/           # Another feature
        ├── ...
```

Test structure mirrors the feature-based organization:
```
src/test/kotlin/com/company/app/
├── common/
└── features/
    ├── auth/
    │   ├── models/
    │   ├── repositories/
    │   ├── services/
    │   └── routes/
    └── users/
        ├── ...
```

## Application Logic Design
1. Route handlers: Handle requests/responses only
2. Services: Contain business logic, call repositories
3. Repositories: Handle database operations
4. Entity classes: Data classes for database models
5. DTOs: Data transfer between layers

## Entities & Data Classes
- Use Kotlin data classes with proper validation
- Define Table objects when using Exposed ORM
- Use UUID or auto-incrementing integers for IDs

## Repository Pattern
- Implement repository interfaces in the domain layer
- Provide concrete implementations in the data layer
- Use dependency injection for repository instances
- Keep repositories focused on data access only

## Service Layer
- Services contain business logic
- Services call repositories, not directly access database
- One service per feature or domain aggregate
- Use dependency injection for service dependencies

## Route Handlers
- Keep route handlers thin - delegate to services
- Handle HTTP concerns only (request/response, status codes)
- Validate input using DTOs
- Return appropriate HTTP status codes

## Error Handling
- Use sealed classes for error types
- Implement global exception handling
- Return consistent error response format
- Log errors appropriately

## Testing
- Write unit tests for services and repositories
- Write integration tests for routes
- Use Kotest for testing framework
- Mock external dependencies
- Test error scenarios

## Security
- Implement authentication and authorization
- Use HTTPS in production
- Validate and sanitize all inputs
- Protect against common vulnerabilities (OWASP Top 10)
- Use secure password hashing
- Implement rate limiting where appropriate

## Code Style
- Follow Kotlin coding conventions
- Use meaningful names
- Keep functions small and focused
- Prefer immutability
- Use extension functions judiciously
- Document public APIs

## Performance
- Use coroutines for asynchronous operations
- Implement proper connection pooling
- Cache frequently accessed data
- Optimize database queries
- Monitor application performance
